/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Replacement } from 'tslint/lib';
import { TypedRule } from 'tslint/lib/rules';
import ts from 'typescript';
const FAILURE_MESSAGE = 'Missing override modifier. Members implemented as part of ' +
    'abstract classes must explicitly set the "override" modifier. ' +
    'More details: https://github.com/microsoft/TypeScript/issues/44457#issuecomment-856202843.';
/**
 * Rule which enforces that class members implementing abstract members
 * from base classes explicitly specify the `override` modifier.
 *
 * This ensures we follow the best-practice of applying `override` for abstract-implemented
 * members so that TypeScript creates diagnostics in both scenarios where either the abstract
 * class member is removed, or renamed.
 *
 * More details can be found here: https://github.com/microsoft/TypeScript/issues/44457.
 */
export class Rule extends TypedRule {
    applyWithProgram(sourceFile, program) {
        return this.applyWithFunction(sourceFile, (ctx) => visitNode(sourceFile, ctx, program));
    }
}
/**
 * For a TypeScript AST node and each of its child nodes, check whether the node is a class
 * element which implements an abstract member but does not have the `override` keyword.
 */
function visitNode(node, ctx, program) {
    // If a class element implements an abstract member but does not have the
    // `override` keyword, create a lint failure.
    if (ts.isClassElement(node) &&
        !hasOverrideModifier(node) &&
        matchesParentAbstractElement(node, program)) {
        ctx.addFailureAtNode(node, FAILURE_MESSAGE, Replacement.appendText(node.getStart(), `override `));
    }
    ts.forEachChild(node, (n) => visitNode(n, ctx, program));
}
/**
 * Checks if the specified class element matches a parent abstract class element. i.e.
 * whether the specified member "implements" an abstract member from a base class.
 */
function matchesParentAbstractElement(node, program) {
    const containingClass = node.parent;
    // If the property we check does not have a property name, we cannot look for similarly-named
    // members in parent classes and therefore return early.
    if (node.name === undefined) {
        return false;
    }
    const propertyName = getPropertyNameText(node.name);
    const typeChecker = program.getTypeChecker();
    // If the property we check does not have a statically-analyzable property name,
    // we cannot look for similarly-named members in parent classes and return early.
    if (propertyName === null) {
        return false;
    }
    return checkClassForInheritedMatchingAbstractMember(containingClass, typeChecker, propertyName);
}
/** Checks if the given class inherits an abstract member with the specified name. */
function checkClassForInheritedMatchingAbstractMember(clazz, typeChecker, searchMemberName) {
    const baseClass = getBaseClass(clazz, typeChecker);
    // If the class is not `abstract`, then all parent abstract methods would need to
    // be implemented, and there is never an abstract member within the class.
    if (baseClass === null || !hasAbstractModifier(baseClass)) {
        return false;
    }
    const matchingMember = baseClass.members.find((m) => m.name !== undefined && getPropertyNameText(m.name) === searchMemberName);
    if (matchingMember !== undefined) {
        return hasAbstractModifier(matchingMember);
    }
    return checkClassForInheritedMatchingAbstractMember(baseClass, typeChecker, searchMemberName);
}
/** Gets the base class for the given class declaration. */
function getBaseClass(node, typeChecker) {
    const baseTypes = getExtendsHeritageExpressions(node);
    if (baseTypes.length > 1) {
        throw Error('Class unexpectedly extends from multiple types.');
    }
    const baseClass = typeChecker.getTypeAtLocation(baseTypes[0]).getSymbol();
    const baseClassDecl = baseClass?.valueDeclaration ?? baseClass?.declarations?.[0];
    if (baseClassDecl !== undefined && ts.isClassDeclaration(baseClassDecl)) {
        return baseClassDecl;
    }
    return null;
}
/** Gets the `extends` base type expressions of the specified class. */
function getExtendsHeritageExpressions(classDecl) {
    if (classDecl.heritageClauses === undefined) {
        return [];
    }
    const result = [];
    for (const clause of classDecl.heritageClauses) {
        if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
            result.push(...clause.types);
        }
    }
    return result;
}
/** Gets whether the specified node has the `abstract` modifier applied. */
function hasAbstractModifier(node) {
    return !!node.modifiers?.some((s) => s.kind === ts.SyntaxKind.AbstractKeyword);
}
/** Gets whether the specified node has the `override` modifier applied. */
function hasOverrideModifier(node) {
    return !!node.modifiers?.some((s) => s.kind === ts.SyntaxKind.OverrideKeyword);
}
/** Gets the property name text of the specified property name. */
function getPropertyNameText(name) {
    if (ts.isComputedPropertyName(name)) {
        return null;
    }
    return name.text;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9JbXBsaWNpdE92ZXJyaWRlQWJzdHJhY3RSdWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGludC1ydWxlcy90c2xpbnQvbm9JbXBsaWNpdE92ZXJyaWRlQWJzdHJhY3RSdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxXQUFXLEVBQTJCLE1BQU0sWUFBWSxDQUFDO0FBQ2pFLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFNUIsTUFBTSxlQUFlLEdBQ25CLDREQUE0RDtJQUM1RCxnRUFBZ0U7SUFDaEUsNEZBQTRGLENBQUM7QUFFL0Y7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxPQUFPLElBQUssU0FBUSxTQUFTO0lBQ3hCLGdCQUFnQixDQUFDLFVBQXlCLEVBQUUsT0FBbUI7UUFDdEUsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzFGLENBQUM7Q0FDRjtBQUVEOzs7R0FHRztBQUNILFNBQVMsU0FBUyxDQUFDLElBQWEsRUFBRSxHQUFnQixFQUFFLE9BQW1CO0lBQ3JFLHlFQUF5RTtJQUN6RSw2Q0FBNkM7SUFDN0MsSUFDRSxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQztRQUN2QixDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQztRQUMxQiw0QkFBNEIsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLEVBQzNDO1FBQ0EsR0FBRyxDQUFDLGdCQUFnQixDQUNsQixJQUFJLEVBQ0osZUFBZSxFQUNmLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUNyRCxDQUFD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SyxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxFQUFFO1lBQ2pELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDOUI7S0FDRjtJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRCwyRUFBMkU7QUFDM0UsU0FBUyxtQkFBbUIsQ0FBQyxJQUFhO0lBQ3hDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDakYsQ0FBQztBQUVELDJFQUEyRTtBQUMzRSxTQUFTLG1CQUFtQixDQUFDLElBQWE7SUFDeEMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUNqRixDQUFDO0FBRUQsa0VBQWtFO0FBQ2xFLFNBQVMsbUJBQW1CLENBQUMsSUFBcUI7SUFDaEQsSUFBSSxFQUFFLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDbkMsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7UmVwbGFjZW1lbnQsIFJ1bGVGYWlsdXJlLCBXYWxrQ29udGV4dH0gZnJvbSAndHNsaW50L2xpYic7XG5pbXBvcnQge1R5cGVkUnVsZX0gZnJvbSAndHNsaW50L2xpYi9ydWxlcyc7XG5pbXBvcnQgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmNvbnN0IEZBSUxVUkVfTUVTU0FHRSA9XG4gICdNaXNzaW5nIG92ZXJyaWRlIG1vZGlmaWVyLiBNZW1iZXJzIGltcGxlbWVudGVkIGFzIHBhcnQgb2YgJyArXG4gICdhYnN0cmFjdCBjbGFzc2VzIG11c3QgZXhwbGljaXRseSBzZXQgdGhlIFwib3ZlcnJpZGVcIiBtb2RpZmllci4gJyArXG4gICdNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDQ0NTcjaXNzdWVjb21tZW50LTg1NjIwMjg0My4nO1xuXG4vKipcbiAqIFJ1bGUgd2hpY2ggZW5mb3JjZXMgdGhhdCBjbGFzcyBtZW1iZXJzIGltcGxlbWVudGluZyBhYnN0cmFjdCBtZW1iZXJzXG4gKiBmcm9tIGJhc2UgY2xhc3NlcyBleHBsaWNpdGx5IHNwZWNpZnkgdGhlIGBvdmVycmlkZWAgbW9kaWZpZXIuXG4gKlxuICogVGhpcyBlbnN1cmVzIHdlIGZvbGxvdyB0aGUgYmVzdC1wcmFjdGljZSBvZiBhcHBseWluZyBgb3ZlcnJpZGVgIGZvciBhYnN0cmFjdC1pbXBsZW1lbnRlZFxuICogbWVtYmVycyBzbyB0aGF0IFR5cGVTY3JpcHQgY3JlYXRlcyBkaWFnbm9zdGljcyBpbiBib3RoIHNjZW5hcmlvcyB3aGVyZSBlaXRoZXIgdGhlIGFic3RyYWN0XG4gKiBjbGFzcyBtZW1iZXIgaXMgcmVtb3ZlZCwgb3IgcmVuYW1lZC5cbiAqXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDQ0NTcuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdWxlIGV4dGVuZHMgVHlwZWRSdWxlIHtcbiAgb3ZlcnJpZGUgYXBwbHlXaXRoUHJvZ3JhbShzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlLCBwcm9ncmFtOiB0cy5Qcm9ncmFtKTogUnVsZUZhaWx1cmVbXSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlXaXRoRnVuY3Rpb24oc291cmNlRmlsZSwgKGN0eCkgPT4gdmlzaXROb2RlKHNvdXJjZUZpbGUsIGN0eCwgcHJvZ3JhbSkpO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGEgVHlwZVNjcmlwdCBBU1Qgbm9kZSBhbmQgZWFjaCBvZiBpdHMgY2hpbGQgbm9kZXMsIGNoZWNrIHdoZXRoZXIgdGhlIG5vZGUgaXMgYSBjbGFzc1xuICogZWxlbWVudCB3aGljaCBpbXBsZW1lbnRzIGFuIGFic3RyYWN0IG1lbWJlciBidXQgZG9lcyBub3QgaGF2ZSB0aGUgYG92ZXJyaWRlYCBrZXl3b3JkLlxuICovXG5mdW5jdGlvbiB2aXNpdE5vZGUobm9kZTogdHMuTm9kZSwgY3R4OiBXYWxrQ29udGV4dCwgcHJvZ3JhbTogdHMuUHJvZ3JhbSkge1xuICAvLyBJZiBhIGNsYXNzIGVsZW1lbnQgaW1wbGVtZW50cyBhbiBhYnN0cmFjdCBtZW1iZXIgYnV0IGRvZXMgbm90IGhhdmUgdGhlXG4gIC8vIGBvdmVycmlkZWAga2V5d29yZCwgY3JlYXRlIGEgbGludCBmYWlsdXJlLlxuICBpZiAoXG4gICAgdHMuaXNDbGFzc0VsZW1lbnQobm9kZSkgJiZcbiAgICAhaGFzT3ZlcnJpZGVNb2RpZmllcihub2RlKSAmJlxuICAgIG1hdGNoZXNQYXJlbnRBYnN0cmFjdEVsZW1lbnQobm9kZSwgcHJvZ3JhbSlcbiAgKSB7XG4gICAgY3R4LmFkZEZhaWx1cmVBdE5vZGUoXG4gICAgICBub2RlLFxuICAgICAgRkFJTFVSRV9NRVNTQUdFLFxuICAgICAgUmVwbGFjZW1lbnQuYXBwZW5kVGV4dChub2RlLmdldFN0YXJ0KCksIGBvdmVycmlkZSBgKSxcbiAgICApO1xuICB9XG5cbiAgdHMuZm9yRWFjaENoaWxkKG5vZGUsIChuKSA9PiB2aXNpdE5vZGUobiwgY3R4LCBwcm9ncmFtKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgY2xhc3MgZWxlbWVudCBtYXRjaGVzIGEgcGFyZW50IGFic3RyYWN0IGNsYXNzIGVsZW1lbnQuIGkuZS5cbiAqIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBtZW1iZXIgXCJpbXBsZW1lbnRzXCIgYW4gYWJzdHJhY3QgbWVtYmVyIGZyb20gYSBiYXNlIGNsYXNzLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzUGFyZW50QWJzdHJhY3RFbGVtZW50KG5vZGU6IHRzLkNsYXNzRWxlbWVudCwgcHJvZ3JhbTogdHMuUHJvZ3JhbSk6IGJvb2xlYW4ge1xuICBjb25zdCBjb250YWluaW5nQ2xhc3MgPSBub2RlLnBhcmVudCBhcyB0cy5DbGFzc0RlY2xhcmF0aW9uO1xuXG4gIC8vIElmIHRoZSBwcm9wZXJ0eSB3ZSBjaGVjayBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbmFtZSwgd2UgY2Fubm90IGxvb2sgZm9yIHNpbWlsYXJseS1uYW1lZFxuICAvLyBtZW1iZXJzIGluIHBhcmVudCBjbGFzc2VzIGFuZCB0aGVyZWZvcmUgcmV0dXJuIGVhcmx5LlxuICBpZiAobm9kZS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBnZXRQcm9wZXJ0eU5hbWVUZXh0KG5vZGUubmFtZSk7XG4gIGNvbnN0IHR5cGVDaGVja2VyID0gcHJvZ3JhbS5nZXRUeXBlQ2hlY2tlcigpO1xuXG4gIC8vIElmIHRoZSBwcm9wZXJ0eSB3ZSBjaGVjayBkb2VzIG5vdCBoYXZlIGEgc3RhdGljYWxseS1hbmFseXphYmxlIHByb3BlcnR5IG5hbWUsXG4gIC8vIHdlIGNhbm5vdCBsb29rIGZvciBzaW1pbGFybHktbmFtZWQgbWVtYmVycyBpbiBwYXJlbnQgY2xhc3NlcyBhbmQgcmV0dXJuIGVhcmx5LlxuICBpZiAocHJvcGVydHlOYW1lID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNoZWNrQ2xhc3NGb3JJbmhlcml0ZWRNYXRjaGluZ0Fic3RyYWN0TWVtYmVyKGNvbnRhaW5pbmdDbGFzcywgdHlwZUNoZWNrZXIsIHByb3BlcnR5TmFtZSk7XG59XG5cbi8qKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNsYXNzIGluaGVyaXRzIGFuIGFic3RyYWN0IG1lbWJlciB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4gKi9cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NGb3JJbmhlcml0ZWRNYXRjaGluZ0Fic3RyYWN0TWVtYmVyKFxuICBjbGF6ejogdHMuQ2xhc3NEZWNsYXJhdGlvbixcbiAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICBzZWFyY2hNZW1iZXJOYW1lOiBzdHJpbmcsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgYmFzZUNsYXNzID0gZ2V0QmFzZUNsYXNzKGNsYXp6LCB0eXBlQ2hlY2tlcik7XG5cbiAgLy8gSWYgdGhlIGNsYXNzIGlzIG5vdCBgYWJzdHJhY3RgLCB0aGVuIGFsbCBwYXJlbnQgYWJzdHJhY3QgbWV0aG9kcyB3b3VsZCBuZWVkIHRvXG4gIC8vIGJlIGltcGxlbWVudGVkLCBhbmQgdGhlcmUgaXMgbmV2ZXIgYW4gYWJzdHJhY3QgbWVtYmVyIHdpdGhpbiB0aGUgY2xhc3MuXG4gIGlmIChiYXNlQ2xhc3MgPT09IG51bGwgfHwgIWhhc0Fic3RyYWN0TW9kaWZpZXIoYmFzZUNsYXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoaW5nTWVtYmVyID0gYmFzZUNsYXNzLm1lbWJlcnMuZmluZChcbiAgICAobSkgPT4gbS5uYW1lICE9PSB1bmRlZmluZWQgJiYgZ2V0UHJvcGVydHlOYW1lVGV4dChtLm5hbWUpID09PSBzZWFyY2hNZW1iZXJOYW1lLFxuICApO1xuXG4gIGlmIChtYXRjaGluZ01lbWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhc0Fic3RyYWN0TW9kaWZpZXIobWF0Y2hpbmdNZW1iZXIpO1xuICB9XG5cbiAgcmV0dXJuIGNoZWNrQ2xhc3NGb3JJbmhlcml0ZWRNYXRjaGluZ0Fic3RyYWN0TWVtYmVyKGJhc2VDbGFzcywgdHlwZUNoZWNrZXIsIHNlYXJjaE1lbWJlck5hbWUpO1xufVxuXG4vKiogR2V0cyB0aGUgYmFzZSBjbGFzcyBmb3IgdGhlIGdpdmVuIGNsYXNzIGRlY2xhcmF0aW9uLiAqL1xuZnVuY3Rpb24gZ2V0QmFzZUNsYXNzKFxuICBub2RlOiB0cy5DbGFzc0RlY2xhcmF0aW9uLFxuICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4pOiB0cy5DbGFzc0RlY2xhcmF0aW9uIHwgbnVsbCB7XG4gIGNvbnN0IGJhc2VUeXBlcyA9IGdldEV4dGVuZHNIZXJpdGFnZUV4cHJlc3Npb25zKG5vZGUpO1xuXG4gIGlmIChiYXNlVHlwZXMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IEVycm9yKCdDbGFzcyB1bmV4cGVjdGVkbHkgZXh0ZW5kcyBmcm9tIG11bHRpcGxlIHR5cGVzLicpO1xuICB9XG5cbiAgY29uc3QgYmFzZUNsYXNzID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24oYmFzZVR5cGVzWzBdKS5nZXRTeW1ib2woKTtcbiAgY29uc3QgYmFzZUNsYXNzRGVjbCA9IGJhc2VDbGFzcz8udmFsdWVEZWNsYXJhdGlvbiA/PyBiYXNlQ2xhc3M/LmRlY2xhcmF0aW9ucz8uWzBdO1xuXG4gIGlmIChiYXNlQ2xhc3NEZWNsICE9PSB1bmRlZmluZWQgJiYgdHMuaXNDbGFzc0RlY2xhcmF0aW9uKGJhc2VDbGFzc0RlY2wpKSB7XG4gICAgcmV0dXJuIGJhc2VDbGFzc0RlY2w7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqIEdldHMgdGhlIGBleHRlbmRzYCBiYXNlIHR5cGUgZXhwcmVzc2lvbnMgb2YgdGhlIHNwZWNpZmllZCBjbGFzcy4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuZHNIZXJpdGFnZUV4cHJlc3Npb25zKFxuICBjbGFzc0RlY2w6IHRzLkNsYXNzRGVjbGFyYXRpb24sXG4pOiB0cy5FeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNbXSB7XG4gIGlmIChjbGFzc0RlY2wuaGVyaXRhZ2VDbGF1c2VzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVzdWx0OiB0cy5FeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXVzZSBvZiBjbGFzc0RlY2wuaGVyaXRhZ2VDbGF1c2VzKSB7XG4gICAgaWYgKGNsYXVzZS50b2tlbiA9PT0gdHMuU3ludGF4S2luZC5FeHRlbmRzS2V5d29yZCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uY2xhdXNlLnR5cGVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEdldHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG5vZGUgaGFzIHRoZSBgYWJzdHJhY3RgIG1vZGlmaWVyIGFwcGxpZWQuICovXG5mdW5jdGlvbiBoYXNBYnN0cmFjdE1vZGlmaWVyKG5vZGU6IHRzLk5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhbm9kZS5tb2RpZmllcnM/LnNvbWUoKHMpID0+IHMua2luZCA9PT0gdHMuU3ludGF4S2luZC5BYnN0cmFjdEtleXdvcmQpO1xufVxuXG4vKiogR2V0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbm9kZSBoYXMgdGhlIGBvdmVycmlkZWAgbW9kaWZpZXIgYXBwbGllZC4gKi9cbmZ1bmN0aW9uIGhhc092ZXJyaWRlTW9kaWZpZXIobm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gISFub2RlLm1vZGlmaWVycz8uc29tZSgocykgPT4gcy5raW5kID09PSB0cy5TeW50YXhLaW5kLk92ZXJyaWRlS2V5d29yZCk7XG59XG5cbi8qKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lIHRleHQgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lLiAqL1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlOYW1lVGV4dChuYW1lOiB0cy5Qcm9wZXJ0eU5hbWUpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKHRzLmlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWUobmFtZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmFtZS50ZXh0O1xufVxuIl19